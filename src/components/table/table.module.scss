@use 'components/constants.module.scss';

$tableWidth: min(100vw, 100vh);
$tableHeight: calc($tableWidth * 1.3);

$bookWidth: constants.$pageWidth;
$bookHeight: constants.$pageHeight;
$bookTop: 10%;

$handSlotTop: 8%;
$handSlotWidth: calc($tableWidth / 3);
$handSlotHeight: constants.$cardHeight;

$tableColor: #763F13;
$tableColorDark: #221100;

.container {
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.room {
  position: absolute;
  perspective: calc($tableWidth);
  perspective-origin: 50% 50%;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;  
}

.room * {
  transform-style: preserve-3d;
}

.room.dragging {
  cursor: grabbing;
}

.table {
  background: $tableColor;
  position: absolute;
  width: $tableWidth;
  height: $tableHeight;
  transform-origin: calc($tableWidth/2) $tableHeight;
  transition: transform 1s ease-in-out;
  pointer-events: all;
  bottom: 0;
  left: calc((100vw - $tableWidth)/2);
}

.table.topDown {
  background: $tableColorDark;
  transform:
      rotateX(20deg)
      translate(0, calc($bookHeight))
      translateZ(calc(-1 * $tableWidth));
}

.table.topDownBookCentered {
  // TODO gradients aren't transitionable, but an overlay with opacity is...
  background: linear-gradient($tableColorDark, $tableColor);
  transform:
      rotateX(20deg)
      translate(calc(-1 * ($bookWidth / 2)), calc($tableHeight - $bookHeight - $bookTop - $handSlotTop))
      translateZ(calc($tableHeight/4))
      ;
}

.table.tilted {
  // TODO gradients aren't transitionable, but an overlay with opacity is...
  background: linear-gradient($tableColorDark, $tableColor);
  transform:
      translateZ(calc($tableHeight * .8))
      translate(0, 0)
      rotateX(constants.$tableTiltAngle)
      ;
}

.book {
  position: absolute;
  top: $bookTop;
  left: 50%;
  width: $bookWidth;
  height: $bookHeight;
  background-color: brown;
}

.hand {
  position: absolute;
  display: flex;
  top: calc($bookTop + $bookHeight + $handSlotTop);
  left: calc((100% - $handSlotWidth) / 2);
  width: $handSlotWidth;
  height: $handSlotHeight;
}

.deck {
  position: absolute;
  top: calc($bookTop + $bookHeight + $handSlotTop);
  left: calc(50% - $bookWidth * .8);
  width: constants.$cardWidth;
  height: constants.$cardHeight;
}

.spread-overlay {
  position: absolute;
  top: calc($bookTop + $bookHeight);
  left: calc($tableWidth/2 - $bookWidth/2);
  width: calc($bookWidth);
  height: constants.$cardHeight;
  transform: translateZ(calc(constants.$cardHeight * 3.5)) rotateX(constants.$tableTiltCorrectionAngle);
  transform-origin: top;
}

.drag-overlay, .status-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

