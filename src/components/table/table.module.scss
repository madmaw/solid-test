@use '../card/card.module.scss';

@value tableWidth: min(100vw, 100vh);
@value tableHeight: calc(tableWidth * 1.3);

// NOTE: this crashes parceljs 
// @value pageWidth: min(30vh, 30vw);
@value pageWidth: 30vh;
@value pageHeight: calc(pageWidth * 1.4);

@value bookWidth: pageWidth;
@value bookHeight: pageHeight;
@value bookTop: 10%;

@value handSlotTop: 8%;
@value handSlotWidth: calc(tableWidth / 2.5);
@value handSlotHeight: cardHeight;

@value tableColor: #763F13;
@value tableColorDark: #221100;

@value tiltAngle: 50deg;

.container {
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.room {
  position: absolute;
  perspective: calc(tableWidth);
  perspective-origin: 50% 50%;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;  
}

.room * {
  transform-style: preserve-3d;
}

.room.dragging {
  cursor: grabbing;
}

.table {
  background: tableColor;
  position: absolute;
  width: tableWidth;
  height: tableHeight;
  transform-origin: calc(tableWidth/2) tableHeight;
  transition: transform 1s ease-in-out;
  pointer-events: all;
  bottom: 0;
  left: calc((100vw - tableWidth)/2);
}

.table.topDown {
  background: tableColorDark;
  transform:
      rotateX(20deg)
      translate(0, calc(bookHeight))
      translateZ(calc(-1 * tableWidth));
}

.table.topDownBookCentered {
  // TODO gradients aren't transitionable, but an overlay with opacity is...
  background: linear-gradient(tableColorDark, tableColor);
  transform:
      rotateX(20deg)
      translate(calc(-1 * (bookWidth / 2)), calc(tableHeight - bookHeight - bookTop - handSlotTop))
      translateZ(calc(tableHeight/4))
      ;
}

.table.tilted {
  // TODO gradients aren't transitionable, but an overlay with opacity is...
  background: linear-gradient(tableColorDark, tableColor);
  transform:
      translateZ(calc(tableHeight * .8))
      translate(0, 0)
      rotateX(tiltAngle)
      ;
}

.book {
  position: absolute;
  top: bookTop;
  left: 50%;
  width: bookWidth;
  height: bookHeight;
  background-color: brown;
}

.hand {
  position: absolute;
  display: flex;
  top: calc(bookTop + bookHeight + handSlotTop);
  left: calc((100% - handSlotWidth) / 2);
  width: handSlotWidth;
  height: handSlotHeight;
}

.deck {
  position: absolute;
  top: calc(bookTop + bookHeight + handSlotTop);
  left: calc(50% - bookWidth + 2vw);
  width: cardWidth;
  height: cardHeight;
}

.spread-overlay {
  position: absolute;
  top: calc(bookTop + bookHeight);
  left: calc(tableWidth/2 - bookWidth/2);
  width: calc(bookWidth);
  height: cardHeight;
  transform: translateZ(calc(cardHeight * 2.5)) rotateX(calc(-80deg));
  transform-origin: top;
}

.drag-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

